// (C) Jamison Dance (jergason) 2011
// MIT License

(function() {
  "use strict";

  //Add the toRad method to the Number object
  if (typeof(Number.prototype.toRad) === "undefined") {
    Number.prototype.toRad = function () {
      return this * (Math.PI / 180);
    };
  }

  if (typeof(Number.prototype.toDeg) === "undefined") {
    Number.prototype.toDeg = function () {
      return this * (180 / Math.PI);
    };
  }


  function Tolmey() {
    this.RADIUS_OF_EARTH_IN_METERS = 6378100;
    this.TILESIZE = 256;
  }


  // Returns an array of tile urls covering a square generated by a given width
  // centered on a given point for a given mapping system.
  // The array is indexed by zoom level, so urls[15] is all the URLs for tiles that cover the area
  // in zoom level 15, ect.
  Tolmey.prototype.getTileURLs = function (opts) {
    var north = this.translate(opts.lat, opts.lon, opts.radius, 0)
      , south = this.translate(opts.lat, opts.lon, opts.radius, 180)
      , west = this.translate(opts.lat, opts.lon, opts.radius, 270)
      , east = this.translate(opts.lat, opts.lon, opts.radius, 90)
      , urls = []
      , origin
      , i, j, z, y0, y1, x0, x1
      , mappingSystem = "openstreetmap"
      , zoom = 12
      , maxZoom = 20
      ;

    if (opts.hasOwnProperty("zoom")) {
      zoom = opts.zoom;
    }
    if (opts.hasOwnProperty("maxZoom")) {
      maxZoom = opts.maxZoom;
    }
    if (opts.hasOwnProperty("mappingSystem")) {
      mappingSystem = opts.mappingSystem;
    }

    for (i = 0; i <= maxZoom; i++) {
      urls[i] = [];
    }


    for (zoom; zoom <= maxZoom; zoom++) {
      y0 = this.getMercatorFromGPS(north.latitude, north.longitude, zoom);
      y1 = this.getMercatorFromGPS(south.latitude, south.longitude, zoom);
      x0 = this.getMercatorFromGPS(west.latitude, west.longitude, zoom);
      x1 = this.getMercatorFromGPS(east.latitude, east.longitude, zoom);

      for (i = x0.x; i <= x1.x; i++) {
        for (j = y0.y; j <= y1.y; j++) {
          urls[zoom].push({ url: this.getTileURL(mappingSystem, i, j, zoom), coords: { zoom: zoom, x: i, y: j }});
        }
      }
    }
    return urls;
  };

  Tolmey.prototype.translate = function (lat, lon, d, brng) {
    var R = this.RADIUS_OF_EARTH_IN_METERS
      , lat2
      , lon2
      , ret
      ;

    lat = lat.toRad();
    lon = lon.toRad();
    brng = brng.toRad();

    lat2 = Math.asin(Math.sin(lat) * Math.cos(d/R) +
                     Math.cos(lat) * Math.sin(d/R) * Math.cos(brng));

    lon2 = lon + Math.atan2(Math.sin(brng) * Math.sin(d/R) * Math.cos(lat),
                            Math.cos(d/R) - Math.sin(lat) * Math.sin(lat2));

    lon2 = (lon2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI;

    ret = {
        latitude: lat2.toDeg()
      , longitude: lon2.toDeg()
    };
    return ret;
  };

  // Wrap around the
  Tolmey.prototype.modGPSAdd = function (x, y) {
    var res = x + y;
    if (res > 180) {
      while (res > 180) {
        res = res - 360;
      }
    }
    else if (res < -180) {
      while (res < -180) {
        res = res + 360;
      }
    }
    return res;
  };

  Tolmey.prototype.distanceInMeters = function (lat_start, long_start, lat_end, long_end) {
    var central_angle_in_radians = this.haversineFunction(lat_start, long_start, lat_end, long_end);
    return central_angle_in_radians * this.RADIUS_OF_EARTH_IN_METERS;
  };

  Tolmey.prototype.haversineFunction = function (lat_start, long_start, lat_end, long_end) {
    var dLat = (lat_end - lat_start).toRad()
      , dLon = (long_end - long_start).toRad()
      , lat1 = lat_start.toRad()
      , lat2 = lat_end.toRad()
      ;

    var a = Math.pow(Math.sin(dLat/2), 2) + Math.cos(lat1)*Math.cos(lat2)*Math.pow(Math.sin(dLon/2),2);
    var centralAngle = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return centralAngle;
  };

  Tolmey.prototype.getMercatorFromGPS = function (lat, lon, zoom) {
    var pixel_x = this.lonToXPixels(zoom, lon.toRad());
    var pixel_y = this.latToYPixels(zoom, lat.toRad());
    var max_pixel = Math.pow(2, zoom) * this.TILESIZE;

    if (pixel_x < 0) {
      pixel_x += max_pixel;
    }
    else if (pixel_x > max_pixel) {
      pixel_x -= max_pixel;
    }

    var tile_x = Math.floor(pixel_x / this.TILESIZE);
    var tile_y = Math.floor(pixel_y / this.TILESIZE);
    if (tile_x >= Math.pow(2, zoom)) {
      tile_x -= Math.pow(2, zoom);
    }

    return { x: tile_x, y: tile_y };
  };

  Tolmey.prototype.getTileURL = function (mapping_system, x, y, zoom) {
    if (mapping_system === "openstreetmap") {
      return "http://tile.openstreetmap.org/" +
      zoom + "/" + x + "/" +
        y + ".png";
    }
    else if (mapping_system === "google") {
      return "http://khm0.google.com/kh/v=95&x=" + x +
       "&y=" + y + "&z=" + zoom + "&s=Gali";
    }
  };

  Tolmey.prototype.latToYPixels = function (zoom, lat) {
    var lat_m = this.atanh(Math.sin(lat));
    var pixel_y = -( (lat_m * this.TILESIZE * Math.exp(zoom * Math.log(2)) ) / (2 * Math.PI)) +
      (Math.exp(zoom * Math.log(2)) * (this.TILESIZE/2) );
    return Math.floor(pixel_y);
  };

  Tolmey.prototype.lonToXPixels = function (zoom, lon) {
    var pixel_x = ( (lon * this.TILESIZE * Math.exp(zoom * Math.log(2)) ) / (2*Math.PI) ) +
      ( Math.exp(zoom * Math.log(2)) * (this.TILESIZE/2) );
    return Math.floor(pixel_x);
  };

  Tolmey.prototype.getEarthRadiusAtZoomLevel = function (zoom_level) {
    //At each zoom level, it takes zoom_level^2 images to span the earth.
    //At zoom level 0, it takes 1 image to cover the earth, so the circumference is 1.
    var circumference = this.getCircumferenceInTiles(zoom_level);
    return circumference / (2 * Math.PI);
  };

  Tolmey.prototype.getCircumferenceInTiles = function (zoom_level) {
    return Math.pow(2, zoom_level);
  };

  Tolmey.prototype.getMetersPerPixel = function (zoom_level, latitude) {
    if (zoom_level < 0) {
      zoom_level = 0;
    }
    if (latitude > 85.05 || latitude < -85.05) {
      throw new Error("Mercator projection is not valid outside of [-85.05, 85.05].");
    }
    return (Math.cos(latitude * (Math.PI / 180)) * 2 * Math.PI * this.RADIUS_OF_EARTH_IN_METERS) /  (this.TILESIZE * this.getCircumferenceInTiles(zoom_level));
  }

  // Taken from http://www.movable-type.co.uk/scripts/latlong.html.
  // Latitude/longitude spherical geodesy formulae & scripts (c) Chris Veness 2002-2011
  Tolmey.prototype.intersection = function(lat1, lon1, brng1, lat2, lon2, brng2) {
    var dLat
      , dLon
      , dist12
      , dist13
      , brngA
      , brngB
      , brng12
      , brng21
      , brng23
      , alpha1
      , alpha2
      , alpha3
      , dist13
      , dist23
      , lat3
      , lon3
      , dLon13
      ;

    lat1 = lat1.toRad();
    lon1 = lon1.toRad();
    lat2 = lat2.toRad();
    lon2 = lon2.toRad();
    brng1 = brng1.toRad();
    brng2 = brng2.toRad();

    dLat = lat2-lat1, dLon = lon2-lon1;

    dist12 = 2*Math.asin( Math.sqrt( Math.sin(dLat/2)*Math.sin(dLat/2) + 
                                    Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)*Math.sin(dLon/2) ) );
    if (dist12 == 0) {
      return null;
    }

    // initial/final bearings between points
    brngA = Math.acos( ( Math.sin(lat2) - Math.sin(lat1)*Math.cos(dist12) ) / 
                     ( Math.sin(dist12)*Math.cos(lat1) ) );
    if (isNaN(brngA)) {
      brngA = 0;  // protect against rounding
    }
    brngB = Math.acos( ( Math.sin(lat1) - Math.sin(lat2)*Math.cos(dist12) ) / 
                     ( Math.sin(dist12)*Math.cos(lat2) ) );

    if (Math.sin(lon2-lon1) > 0) {
      brng12 = brngA;
      brng21 = 2*Math.PI - brngB;
    }
    else {
      brng12 = 2*Math.PI - brngA;
      brng21 = brngB;
    }

    alpha1 = (brng1 - brng12 + Math.PI) % (2*Math.PI) - Math.PI;  // angle 2-1-3
    alpha2 = (brng21 - brng2 + Math.PI) % (2*Math.PI) - Math.PI;  // angle 1-2-3


    if (Math.sin(alpha1)==0 && Math.sin(alpha2)==0) {
      // infinite intersections
      return null;
    }
    if (Math.sin(alpha1)*Math.sin(alpha2) < 0) {
      // ambiguous intersection
      return null;
    }

    //alpha1 = Math.abs(alpha1);
    //alpha2 = Math.abs(alpha2);
    // ... Ed Williams takes abs of alpha1/alpha2, but seems to break calculation?

    alpha3 = Math.acos( -Math.cos(alpha1)*Math.cos(alpha2) + 
                       Math.sin(alpha1)*Math.sin(alpha2)*Math.cos(dist12) );
    dist13 = Math.atan2( Math.sin(dist12)*Math.sin(alpha1)*Math.sin(alpha2), 
                        Math.cos(alpha2)+Math.cos(alpha1)*Math.cos(alpha3) )
    lat3 = Math.asin( Math.sin(lat1)*Math.cos(dist13) + 
                     Math.cos(lat1)*Math.sin(dist13)*Math.cos(brng1) );
    dLon13 = Math.atan2( Math.sin(brng1)*Math.sin(dist13)*Math.cos(lat1), 
                        Math.cos(dist13)-Math.sin(lat1)*Math.sin(lat3) );
    lon3 = lon1+dLon13;
    lon3 = (lon3+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180ยบ
    // console.log('Math.sin(lat1)*Math.cos(dist13)', Math.sin(lat1)*Math.cos(dist13));
    // console.log(' Math.cos(lat1)*Math.sin(dist13)*Math.cos(brng1)',  Math.cos(lat1)*Math.sin(dist13)*Math.cos(brng1));
    // console.log('Math.cos(brng1)', Math.cos(brng1));
    // console.log('bearning13', brng1);
    // console.log('alpha3 is ', alpha3, ' dist13 is ', dist13, ' lat3 is ', lat3, ' dlon13 is ', dLon13, ' lon3 is ', lon3);
    // console.log('dist12 is ', dist12, ' alpha1 is ', alpha1, ' alpha2 is ', alpha2);

    return { latitude: lat3.toDeg(), longitude: lon3.toDeg() };
  }

  Tolmey.prototype.xPixelToLon = function (zoom, xPixel) {
    var lon = ((xPixel - ( Math.exp(zoom * Math.log(2)) * (this.TILESIZE / 2))) * 2 * Math.PI) /
      (this.TILESIZE * Math.exp(zoom * Math.log(2)));
    return lon;
  };

  Tolmey.prototype.yPixelToLat = function (zoom, yPixel) {
    var latM = (-( yPixel - ( Math.exp(zoom * Math.log(2)) * (this.TILESIZE / 2))) * (2 * Math.PI)) /
      (this.TILESIZE * Math.exp(zoom * Math.log(2)));
    var lat = Math.atan(this.tanh(latM));
    return lat;
  };

  Tolmey.prototype.atanh  = function (x) {
    return 0.5 * Math.log((1 + x) / (1 - x));
  };

  Tolmey.prototype.tanh = function (x) {
    return (Math.exp(2 * x) - 1) / (Math.exp(2 * x) + 1);
  };

  Tolmey.prototype.within = function (a, b, width) {
    return (Math.abs(a - b) < width);
  };

  module.exports = Tolmey;
}());
