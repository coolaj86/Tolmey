// (C) Jamison Dance (jergason) 2011
// MIT License

(function() {
  "use strict";

  //Add the toRad method to the Number object
  if (typeof(Number.prototype.toRad) === "undefined") {
    Number.prototype.toRad = function () {
      return this * (Math.PI / 180);
    };
  }

  if (typeof(Number.prototype.toDeg) === "undefined") {
    Number.prototype.toDeg = function () {
      return this * (180 / Math.PI);
    };
  }

  //Add math trig functions
  if (typeof(Math.atanh) === "undefined") {
    Math.atanh = function (x) {
      return 0.5 * Math.log((1 + x) / (1 - x));
    };
  }

  if (typeof(Math.tanh) === "undefined") {
    Math.tanh = function (x) {
      return (Math.exp(2 * x) - 1) / (Math.exp(2 * x) + 1);
    };
  }

  function Tolmey(opts) {
    if (!opts) {
      opts = {}
    }

    if (!opts.tileSize) {
      //Default tile size in pixels
      opts.tileSize = 256
    }

    function modGPSAdd(x, y) {
      var res = x + y;
      if (res > 180) {
        while (res > 180) {
          res = res - 360;
        }
      }
      else if (res < -180) {
        while (res < -180) {
          res = res + 360;
        }
      }
      return res;
    };

    function haversineFunction(lat_start, long_start, lat_end, long_end) {
      var dLat = (lat_end - lat_start).toRad()
        , dLon = (long_end - long_start).toRad()
        , lat1 = lat_start.toRad()
        , lat2 = lat_end.toRad()
        ;

      var a = Math.pow(Math.sin(dLat/2), 2) + Math.cos(lat1)*Math.cos(lat2)*Math.pow(Math.sin(dLon/2),2);
      var centralAngle = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return centralAngle;
    };

    this.TILESIZE = opts.tileSize;
    this.RADIUS_OF_EARTH_IN_METERS = 6378100;

    return {
      // Returns an array of tile urls covering a square generated by a given width
      // centered on a given point for a given mapping system.
      // The array is indexed by zoom level, so urls[15] is all the URLs for tiles that cover the area
      // in zoom level 15, ect.
      getTileURLs: function (opts) {
        var north = this.translate(opts.lat, opts.lon, opts.radius, 0)
          , south = this.translate(opts.lat, opts.lon, opts.radius, 180)
          , west = this.translate(opts.lat, opts.lon, opts.radius, 270)
          , east = this.translate(opts.lat, opts.lon, opts.radius, 90)
          , urls = []
          , origin
          , i, j, z, y0, y1, x0, x1
          , mappingSystem = "openstreetmap"
          , zoom = 12
          , maxZoom = 20
          ;

        if (opts.hasOwnProperty("zoom")) {
          zoom = opts.zoom;
        }
        if (opts.hasOwnProperty("maxZoom")) {
          maxZoom = opts.maxZoom;
        }
        if (opts.hasOwnProperty("mappingSystem")) {
          mappingSystem = opts.mappingSystem;
        }

        for (i = 0; i <= maxZoom; i++) {
          urls[i] = [];
        }


        for (zoom; zoom <= maxZoom; zoom++) {
          y0 = this.getMercatorFromGPS(north.latitude, north.longitude, zoom);
          y1 = this.getMercatorFromGPS(south.latitude, south.longitude, zoom);
          x0 = this.getMercatorFromGPS(west.latitude, west.longitude, zoom);
          x1 = this.getMercatorFromGPS(east.latitude, east.longitude, zoom);

          for (i = x0.x; i <= x1.x; i++) {
            for (j = y0.y; j <= y1.y; j++) {
              urls[zoom].push({ url: this.getTileURL(mappingSystem, i, j, zoom), coords: { zoom: zoom, x: i, y: j }});
            }
          }
        }
        return urls;
      },

      translate: function (lat, lon, d, brng) {
        var R = this.RADIUS_OF_EARTH_IN_METERS
          , lat2
          , lon2
          , ret
          ;

        lat = lat.toRad();
        lon = lon.toRad();
        brng = brng.toRad();

        lat2 = Math.asin(Math.sin(lat) * Math.cos(d/R) +
                         Math.cos(lat) * Math.sin(d/R) * Math.cos(brng));

        lon2 = lon + Math.atan2(Math.sin(brng) * Math.sin(d/R) * Math.cos(lat),
                                Math.cos(d/R) - Math.sin(lat) * Math.sin(lat2));

        lon2 = (lon2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI;

        ret = {
            latitude: lat2.toDeg()
          , longitude: lon2.toDeg()
        };
        return ret;
      },


      distanceInMeters: function (lat_start, long_start, lat_end, long_end) {
        var central_angle_in_radians = this.haversineFunction(lat_start, long_start, lat_end, long_end);
        return central_angle_in_radians * this.RADIUS_OF_EARTH_IN_METERS;
      },


      getMercatorFromGPS: function (lat, lon, zoom) {
        var pixel_x = this.lonToXPixels(lon.toRad(), zoom);
        var pixel_y = this.latToYPixels(lat.toRad(), zoom);
        var max_pixel = Math.pow(2, zoom) * this.TILESIZE;

        if (pixel_x < 0) {
          pixel_x += max_pixel;
        }
        else if (pixel_x > max_pixel) {
          pixel_x -= max_pixel;
        }

        var tile_x = Math.floor(pixel_x / this.TILESIZE);
        var tile_y = Math.floor(pixel_y / this.TILESIZE);
        if (tile_x >= Math.pow(2, zoom)) {
          tile_x -= Math.pow(2, zoom);
        }

        return { x: tile_x, y: tile_y };
      },

      getTileURL: function (mapping_system, x, y, zoom) {
        if (mapping_system === "openstreetmap") {
          return "http://tile.openstreetmap.org/" +
          zoom + "/" + x + "/" +
            y + ".png";
        }
        else if (mapping_system === "google") {
          return "http://khm0.google.com/kh/v=95&x=" + x +
           "&y=" + y + "&z=" + zoom + "&s=Gali";
        }
      },

      // Takes lat in radians and a zoom, and returns a y pixel
      latToYPixels: function (lat, zoom) {
        var lat_m = Math.atanh(Math.sin(lat));
        var pixel_y = -( (lat_m * this.TILESIZE * Math.exp(zoom * Math.log(2)) ) / (2 * Math.PI)) +
          (Math.exp(zoom * Math.log(2)) * (this.TILESIZE/2) );
        return Math.floor(pixel_y);
      },

      // Takes the longitude in radians and tile zoom, and returns an x pixel.
      lonToXPixels: function (lon, zoom) {
        var pixel_x = ( (lon * this.TILESIZE * Math.exp(zoom * Math.log(2)) ) / (2*Math.PI) ) +
          ( Math.exp(zoom * Math.log(2)) * (this.TILESIZE/2) );
        return Math.floor(pixel_x);
      },

      latLonToPixel: function (lat, lon, zoom) {
        return { x: this.lonToXPixels(lon, zoom), y: this.latToYPixels(lat, zoom) };
      },

      xPixelToLon: function (xPixel, zoom) {
        var lon = ((xPixel - ( Math.exp(zoom * Math.log(2)) * (this.TILESIZE / 2))) * 2 * Math.PI) /
          (this.TILESIZE * Math.exp(zoom * Math.log(2)));
        return lon;
      },

      yPixelToLat: function (yPixel, zoom) {
        var latM = (-( yPixel - ( Math.exp(zoom * Math.log(2)) * (this.TILESIZE / 2))) * (2 * Math.PI)) /
          (this.TILESIZE * Math.exp(zoom * Math.log(2)));
        var lat = Math.atan(Math.tanh(latM));
        return lat;
      },

      getCircumferenceInTiles: function (zoom_level) {
        return Math.pow(2, zoom_level);
      },

      getMetersPerPixel: function (zoom_level, latitude) {
        if (zoom_level < 0) {
          zoom_level = 0;
        }
        if (latitude > 85.05 || latitude < -85.05) {
          throw new Error("Mercator projection is not valid outside of [-85.05, 85.05].");
        }
        return (Math.cos(latitude * (Math.PI / 180)) * 2 * Math.PI * this.RADIUS_OF_EARTH_IN_METERS) /  (this.TILESIZE * this.getCircumferenceInTiles(zoom_level));
      },

      // Taken from http://www.movable-type.co.uk/scripts/latlong.html.
      // Latitude/longitude spherical geodesy formulae & scripts (c) Chris Veness 2002-2011
      intersection: function(lat1, lon1, brng1, lat2, lon2, brng2) {
        var dLat
          , dLon
          , dist12
          , dist13
          , brngA
          , brngB
          , brng12
          , brng21
          , brng23
          , alpha1
          , alpha2
          , alpha3
          , dist13
          , dist23
          , lat3
          , lon3
          , dLon13
          ;

        lat1 = lat1.toRad();
        lon1 = lon1.toRad();
        lat2 = lat2.toRad();
        lon2 = lon2.toRad();
        brng1 = brng1.toRad();
        brng2 = brng2.toRad();

        dLat = lat2-lat1, dLon = lon2-lon1;

        dist12 = 2*Math.asin( Math.sqrt( Math.sin(dLat/2)*Math.sin(dLat/2) +
                                        Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)*Math.sin(dLon/2) ) );
        if (dist12 == 0) {
          return null;
        }

        // initial/final bearings between points
        brngA = Math.acos( ( Math.sin(lat2) - Math.sin(lat1)*Math.cos(dist12) ) /
                         ( Math.sin(dist12)*Math.cos(lat1) ) );
        if (isNaN(brngA)) {
          brngA = 0;  // protect against rounding
        }
        brngB = Math.acos( ( Math.sin(lat1) - Math.sin(lat2)*Math.cos(dist12) ) /
                         ( Math.sin(dist12)*Math.cos(lat2) ) );

        if (Math.sin(lon2-lon1) > 0) {
          brng12 = brngA;
          brng21 = 2*Math.PI - brngB;
        }
        else {
          brng12 = 2*Math.PI - brngA;
          brng21 = brngB;
        }

        alpha1 = (brng1 - brng12 + Math.PI) % (2*Math.PI) - Math.PI;  // angle 2-1-3
        alpha2 = (brng21 - brng2 + Math.PI) % (2*Math.PI) - Math.PI;  // angle 1-2-3


        if (Math.sin(alpha1)==0 && Math.sin(alpha2)==0) {
          // infinite intersections
          return null;
        }
        if (Math.sin(alpha1)*Math.sin(alpha2) < 0) {
          // ambiguous intersection
          return null;
        }

        alpha3 = Math.acos( -Math.cos(alpha1)*Math.cos(alpha2) +
                           Math.sin(alpha1)*Math.sin(alpha2)*Math.cos(dist12) );
        dist13 = Math.atan2( Math.sin(dist12)*Math.sin(alpha1)*Math.sin(alpha2),
                            Math.cos(alpha2)+Math.cos(alpha1)*Math.cos(alpha3) )
        lat3 = Math.asin( Math.sin(lat1)*Math.cos(dist13) +
                         Math.cos(lat1)*Math.sin(dist13)*Math.cos(brng1) );
        dLon13 = Math.atan2( Math.sin(brng1)*Math.sin(dist13)*Math.cos(lat1),
                            Math.cos(dist13)-Math.sin(lat1)*Math.sin(lat3) );
        lon3 = lon1+dLon13;
        lon3 = (lon3+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180º

        return { latitude: lat3.toDeg(), longitude: lon3.toDeg() };
      },

    };
  }

  function create() {
    return new Tolmey();
  }

  module.exports.create = create;
}());
